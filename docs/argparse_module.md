## Документация по модулю argparse (очень подробное объяснение)

Цель этого текста — не просто перечислить функции `argparse`,
а объяснить **каждое ключевое слово простым языком**, так чтобы
разобрался человек, который впервые видит модуль.

---

### 1. Что такое argparse и зачем он нужен

Когда мы запускаем программу из командной строки, мы часто пишем что‑то вроде:

```bash
python my_script.py --input data.txt --verbose
```

Здесь:

- `python` — это команда операционной системы: “запусти интерпретатор Python”;
- `my_script.py` — файл с нашим кодом;
- `--input data.txt` и `--verbose` — **аргументы командной строки**,
  то есть дополнительные параметры для программы.

Без `argparse` нам бы пришлось:

- лезть в список `sys.argv` (это список строк с аргументами);
- вручную проверять, есть ли `--input`, что за ним идёт и т.д.;
- самим писать сообщения об ошибках, если пользователь что‑то перепутал;
- самим делать красивую справку `--help`.

Модуль **`argparse` делает всё это за нас**:

- даёт способ **описать**, какие аргументы программа принимает;
- **разбирает** реальные аргументы (строки) в удобный объект;
- **проверяет** корректность (тип, наличие, диапазон, выбор из списка);
- автоматически делает команду `--help` с аккуратной справкой.

Важно: `argparse` — это **стандартный модуль Python**.
Его не нужно устанавливать через `pip`, он входит “из коробки”.

---

### 2. Основной объект: ArgumentParser

Почти любая программа на `argparse` начинается с создания **объекта парсера**:

```python
import argparse

parser = argparse.ArgumentParser(
    prog="my-tool",
    description="Короткое описание программы",
)
```

Разберём всё по частям:

- `argparse.ArgumentParser` — класс, который:
  - “знает” обо всех аргументах и флагах программы;
  - умеет их разбирать;
  - умеет печатать `--help`.
- `prog` — имя программы, которое будет показано в заголовке справки.
  Если не указать, Python сам возьмёт имя файла.
- `description` — текст, который объясняет, что делает программа.
  Пользователь увидит его в начале `--help`.

У `ArgumentParser` есть важные методы:

- `add_argument(...)` — объявить новый аргумент (позиционный или флаг);
- `add_subparsers(...)` — добавить поддержку **подкоманд** (как в `git add`, `git commit`);
- `parse_args()` — разобрать реальные аргументы командной строки;
- `print_help()` / `print_usage()` — явно вывести справку.

Результат вызова `parse_args()` — объект типа `Namespace`.
К нему можно обращаться как к обычному объекту:
`args.input`, `args.verbose`, и т.д.

---

### 3. Позиционные аргументы: что это и как они работают

**Позиционный аргумент** — это аргумент, который указывается **без** `-` или `--`
и определяется именно **по позиции**.

Пример:

```bash
python tool.py greet Alex
```

Здесь `greet` и `Alex` могут быть позиционными аргументами.

В коде:

```python
parser.add_argument("name", help="Имя пользователя")
```

Разбор:

- `"name"` — это **имя аргумента внутри программы**, не то, что пишет пользователь,
  а то, как мы будем к нему обращаться: `args.name`;
- `help` — текст, описывающий этот аргумент в `--help`.

Если пользователь **не передаст** позиционный аргумент, `argparse`
сразу сообщит об ошибке и покажет краткую справку.

---

### 4. Опциональные аргументы и флаги

**Опциональные аргументы** — это параметры, которые начинаются с `-` или `--`.

Например:

```bash
python tool.py --verbose
python tool.py -v
```

В коде:

```python
parser.add_argument(
    "-v",
    "--verbose",
    action="store_true",
    help="включить подробный вывод",
)
```

Разберём параметры `add_argument`:

- `"-v"` — короткое имя (одна буква с `-`);
- `"--verbose"` — длинное имя (слово с `--`);
- `action="store_true"` — если флаг есть в командной строке,
  в `args.verbose` будет `True`, если нет — `False`.
- `help` — текст для справки.

Если опциональный аргумент **ожидает значение**, мы обычно не задаём `action`,
и `argparse` по умолчанию считает, что после флага идёт **значение**:

```python
parser.add_argument(
    "--output",
    metavar="PATH",
    help="путь к файлу, куда сохранить результат",
)
```

Если пользователь напишет:

```bash
python tool.py --output result.txt
```

то в Python будет `args.output == "result.txt"`.

`metavar="PATH"` — это просто красивое имя, которое будет показано в `--help`,
чтобы намекнуть, что здесь ожидается путь к файлу.

---

### 5. Типы (`type`) и преобразование входных данных

По умолчанию `argparse` всё читает как **строки**.
Но часто нам нужны числа или другие типы.

Пример:

```python
parser.add_argument(
    "--times",
    type=int,
    default=1,
    help="сколько раз выполнить действие",
)
```

- `type=int` — `argparse` попробует преобразовать введённое значение в `int`;
- если пользователь введёт что-то некорректное
  (например, `--times abc`), `argparse` сам:
  - покажет понятное сообщение об ошибке;
  - завершит программу с ненулевым кодом.

Можно использовать и более сложные типы:

- `float` — числа с плавающей точкой;
- `pathlib.Path` — удобный объект для представления пути к файлу;
- любая своя функция, которая принимает строку и возвращает готовое значение.

---

### 6. Множественные значения (`nargs`)

Иногда один аргумент должен принять **несколько значений**.

Например:

```bash
python tool.py calc add 1 2 3 4
```

Здесь `1 2 3 4` — это список чисел.

В коде:

```python
parser.add_argument(
    "numbers",
    type=float,
    nargs="+",
    help="список чисел для обработки",
)
```

Параметр `nargs`:

- `"+"` — “одно или больше значений”;
- `"*"` — “ноль или больше значений”;
- конкретное число, например `3` — “ровно три значения”.

В результате `args.numbers` будет **списком** чисел (`[1.0, 2.0, 3.0, 4.0]`).

---

### 7. Ограничения по значениям (`choices`)

Бывает, что аргумент должен принимать **одно из фиксированного набора значений**.

Пример:

```python
parser.add_argument(
    "operation",
    choices=["add", "sub", "mul", "div"],
    help="операция: add, sub, mul, div",
)
```

Если пользователь введёт что-то вне этого списка (например, `mod`),
`argparse` покажет:

- что ввели;
- какие варианты разрешены.

Это убирает необходимость вручную проверять значение и писать собственные сообщения.

---

### 8. Подкоманды (`subparsers`) — как в git

Подкоманды можно воспринимать как “подпрограммы” внутри одной программы.

Пример из реального мира: `git`:

- `git add` — одна команда;
- `git commit` — другая;
- `git push` — третья.

С `argparse` можно сделать похоже:

```python
subparsers = parser.add_subparsers(dest="command", required=True)

greet = subparsers.add_parser("greet", help="приветствие")
calc = subparsers.add_parser("calc", help="калькулятор")
```

- `add_subparsers()` возвращает объект, через который мы создаём
  отдельные парсеры для каждой подкоманды;
- `dest="command"` — имя поля в `args`, куда положится выбранная подкоманда;
- `required=True` — подкоманда **обязательна**, без неё программа не запускается.

Часто каждой подкоманде назначают свою функцию:

```python
greet.set_defaults(func=handle_greet)
calc.set_defaults(func=handle_calc)
```

Потом в `main()` можно просто вызвать:

```python
args.func(args)
```

И нужная логика исполнится сама, без кучи `if/elif`.

---

### 9. Группы аргументов и взаимно исключающие флаги

Иногда нужно:

1. Логически **объединить** связанные аргументы в справке;
2. Запретить пользователю **одновременно включить два конфликтующих флага**.

Для первого есть `add_argument_group()`:
он влияет в основном на оформление `--help`.

Для второго — `add_mutually_exclusive_group()`:

```python
group = parser.add_mutually_exclusive_group()
group.add_argument("--int", action="store_true")
group.add_argument("--precise", action="store_true")
```

Теперь нельзя написать `--int --precise` одновременно —
`argparse` сам покажет ошибку.

Это удобно, когда два режима смысла **не имеют вместе**
(например, “тихий” и “подробный” режимы логирования).

---

### 10. Чтение аргументов из файла (`fromfile_prefix_chars`)

Если команда получается очень длинной, удобно сохранить аргументы в файл.

В `ArgumentParser` можно указать:

```python
parser = argparse.ArgumentParser(fromfile_prefix_chars="@")
```

Теперь, если в командной строке встретится что-то вроде:

```bash
python tool.py @args.txt
```

`argparse`:

- откроет файл `args.txt`;
- прочитает оттуда аргументы (обычно по одному токену на строку);
- “подставит” их так, как будто вы написали всё прямо в командной строке.

Это описано в официальной документации и особенно полезно,
когда:

- много параметров;
- вы часто повторяете похожие команды;
- нужно запускать один и тот же сценарий с минимальными изменениями.

---

### 11. Справка (`--help`) и форматирование

Большой плюс `argparse`:

- он **сам** делает справку;
- сам форматирует блоки, список аргументов, значения по умолчанию.

Например, вызов:

```bash
python tool.py --help
```

выведет:

- общее описание программы (`description`);
- раздел “позиционные аргументы”;
- раздел “опциональные аргументы”;
- описание подкоманд (если есть `subparsers`);
- `epilog` (обычно с примерами).

Параметр `formatter_class` позволяет управлять внешним видом:

- по умолчанию Python может “ломать” строки по своему;
- `argparse.RawDescriptionHelpFormatter` говорит:
  “оставь переводы строк как есть”.

Это важно, если вы хотите сами аккуратно сверстать примеры команд.

---

### 12. Ограничения и когда argparse может быть неудобным

По опыту разработчиков и статьям:

1. При очень больших CLI с десятками подкоманд
   код конфигурации парсера может стать громоздким.
2. Для “супер‑удобного” API на уровне Python-кода
   некоторые предпочитают библиотеки вроде:
   - `click`;
   - `typer`.
   Они иногда используют `argparse` внутри, но дают другой стиль написания кода.
3. `argparse` сам по себе не занимается “красотой” вывода
   (цвета, таблицы, рамки) — за это отвечают другие библиотеки
   (например, `rich`). Поэтому в реальных проектах часто делают связку:
   `argparse` + “красивый вывод”.

Тем не менее:

- `argparse` — **официальный стандарт** из документации Python;
- он надёжен, стабилен и доступен “из коробки”;
- его достаточно для огромного количества практических задач.

---

### 13. Какие источники полезно посмотреть (в свободной форме)

- **Официальная документация Python по `argparse`**  
  Там максимально точное и полное описание всех параметров и примеров.
- **Учебные статьи и туториалы (например, Real Python, блоги разработчиков)**  
  Они показывают, как “правильно” структурировать реальные программы,
  как разбивать код на функции, как использовать подкоманды.
- **Сравнения `argparse` с `click` и `typer`**  
  Помогают понять, в каких проектах лучше остаться на `argparse`,
  а когда есть смысл перейти к более высокоуровневым библиотекам.

Эта программа `argparse_demo.py` как раз опирается на основные приёмы
из этих источников: подкоманды, типы, `choices`, группы флагов и
чтение аргументов из файла.



