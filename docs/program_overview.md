## Обзор обучающей программы на argparse (подробно и “по‑человечески”)

Эта документация написана так, чтобы в ней разобрался человек,
который **только начинает** знакомство и с Python, и с модулем `argparse`.
Задача текста — объяснить не только “что делает код”, но и **зачем это сделано именно так**.

---

### 1. Что вообще делает программа `argparse_demo.py`

`argparse_demo.py` — это **консольная программа** (CLI-приложение).
Это значит, что мы не кликаем по кнопкам мышкой, а **запускаем её через командную строку** и
передаём параметры в виде текста:

```bash
python argparse_demo.py greet Alex --times 3 --shout
```

Эта одна строка уже содержит:

- `python` — команда операционной системы “запусти интерпретатор Python”;
- `argparse_demo.py` — имя файла с нашей программой;
- `greet` — **подкоманда** (что именно программа должна сделать: поприветствовать);
- `Alex` — **позиционный аргумент**, здесь это имя человека;
- `--times 3` — **опциональный аргумент** (флаг) с числом: сколько раз повторить приветствие;
- `--shout` — флаг без значения: если он есть, значит нужно “кричать” (верхний регистр).

Главная цель программы — **показать на живом примере**, как с помощью модуля `argparse`
описать такие аргументы, аккуратно их разобрать и получить удобный объект `args`,
из которого можно брать готовые значения (`args.name`, `args.times`, и т.д.).

---

### 2. Общая архитектура программы (из каких блоков она состоит)

Внутри `argparse_demo.py` есть несколько важных частей:

1. **Dataclass `AppConfig`** — это маленький “контейнер” настроек:
   он хранит общие для всей программы параметры: `verbose` и `output`.
   Dataclass — это просто удобный способ описать “структуру данных” в Python.

2. **Функция `build_parser()`** — сердце программы.
   Она создаёт и настраивает объект `ArgumentParser`, то есть говорит:
   “Вот какие команды, флаги и аргументы моя программа понимает”.

3. **Функция `main()`** — точка входа.
   Она:
   - вызывает `build_parser()`;
   - разбирает реальные аргументы командной строки с помощью `parse_args()`;
   - по результату запускает нужную подкоманду (правильную функцию-обработчик).

4. **Функции-обработчики подкоманд**:
   - `handle_greet()` — всё, что связано с командой `greet`;
   - `handle_calc()` — обработка команды `calc`;
   - `handle_file_stats()` — обработка подкоманды `file stats`.

5. **Функция `write_output()`** — единое место, где программа решает,
   **как выводить результат**:
   - в консоль (просто `print`);
   - или в файл (если указан `--output`).
   Она ещё и красиво оформляет вывод в виде “блока” с рамкой.

---

### 3. Функция `build_parser()` — пошагово, что в ней происходит

```python
parser = argparse.ArgumentParser(
    prog="argparse-demo",
    description=(
        "Обучающий пример использования модуля argparse.\n"
        "Программа демонстрирует несколько подкоманд и разные типы аргументов."
    ),
    epilog=(
        "Примеры использования:\n"
        "  argparse-demo greet Alex --times 3 --shout\n"
        "  argparse-demo calc add 1 2 3 4 --precise\n"
        "  argparse-demo file stats sample.txt --verbose\n"
        "  argparse-demo @args.txt  (аргументы из файла)"
    ),
    formatter_class=argparse.RawDescriptionHelpFormatter,
    fromfile_prefix_chars="@",
)
```

- `prog` — имя программы, которое будет показано в справке (`--help`).
- `description` — текст, который описывает, что вообще делает программа.
- `epilog` — текст внизу справки, обычно туда кладут **примеры** команд.
- `formatter_class` — класс форматтера, который говорит,
  как именно печатать многострочные тексты.
  `RawDescriptionHelpFormatter` означает: “не ломай мои переводы строк, печатай как есть”.
- `fromfile_prefix_chars="@"` — особенность:
  если в командной строке встретится `@имя_файла`, `argparse` прочитает аргументы **из этого файла**.

Дальше мы описываем **глобальные флаги**:

```python
parser.add_argument(
    "-v",
    "--verbose",
    action="store_true",
    help="подробный вывод (дополнительная отладочная информация)",
)
```

- `-v` и `--verbose` — короткое и длинное имя одного и того же флага;
- `action="store_true"` — если флаг есть, то `args.verbose` будет `True`,
  если флага нет — `False`;
- `help` — строка, которая попадёт в `--help`.

```python
parser.add_argument(
    "-o",
    "--output",
    metavar="PATH",
    help="если указано — вывод сохранить в файл, а не в стандартный вывод",
)
```

- здесь `action` не указан, значит по умолчанию это аргумент с **значением**,
  которое будет строкой (путь к файлу);
- `metavar="PATH"` — как обозначить это значение в справке (`--help`).

Теперь подкоманды:

```python
subparsers = parser.add_subparsers(
    title="подкоманды",
    dest="command",
    required=True,
    metavar="COMMAND",
    help="действие, которое нужно выполнить (например, greet, calc, file)",
)
```

- `add_subparsers()` говорит: “у меня будут разные **подкоманды**,
  каждая со своим набором аргументов”;
- `dest="command"` — название поля в `args`, куда положится имя выбранной подкоманды;
- `required=True` — без выбора подкоманды программа не запустится,
  `argparse` сам покажет ошибку и справку.

---

### 4. Подкоманда `greet` — разбор до мелочей

```python
greet = subparsers.add_parser(
    "greet",
    help="приветствие пользователя",
    description="Печатает одно или несколько приветствий для указанного имени.",
)
```

- `"greet"` — имя подкоманды: будете писать `greet` в командной строке;
- `help` — краткое описание (показывается в общем `--help`);
- `description` — более подробный текст, который видно в `python argparse_demo.py greet --help`.

Дальше у `greet` свои аргументы:

```python
greet.add_argument("name", help="имя человека, которого надо поприветствовать")
```

- `name` без `-` или `--` — это **позиционный аргумент**:
  он обязателен и определяется по позиции в команде:
  `greet Alex` — здесь `Alex` попадает в `args.name`.

```python
greet.add_argument(
    "-t",
    "--times",
    type=int,
    default=1,
    help="сколько раз вывести приветствие (по умолчанию 1)",
)
```

- `-t` / `--times` — флаг с числовым значением;
- `type=int` — `argparse` сам попробует преобразовать строку в `int`;
- `default=1` — если флаг не указан, то используется 1.

```python
greet.add_argument(
    "--shout",
    action="store_true",
    help="если указано — печатать прописными буквами",
)
```

- это флаг без значения: либо есть (`True`), либо нет (`False`).

Ключевая строка:

```python
greet.set_defaults(func=handle_greet)
```

Она говорит: “если выбрана подкоманда `greet`, то в `args.func` положить функцию `handle_greet`”.
Благодаря этому в `main()` мы можем просто вызвать `args.func(args, config)` и не писать
кучу `if command == "greet": ...`.

---

### 5. Подкоманда `calc` — пример с выбором операций и группой флагов

```python
calc = subparsers.add_parser(
    "calc",
    help="простые арифметические операции",
    description="Выполняет арифметические операции над списком чисел.",
)
```

Основные аргументы:

```python
calc.add_argument(
    "operation",
    choices=["add", "sub", "mul", "div"],
    help="операция: add, sub, mul, div",
)
```

- позиционный аргумент `operation`;
- `choices=[...]` — `argparse` автоматически проверит, что введено одно из этих слов,
  иначе покажет ошибку.

```python
calc.add_argument(
    "numbers",
    type=float,
    nargs="+",
    help="список чисел для обработки",
)
```

- `numbers` — позиционный аргумент со **множеством значений**;
- `nargs="+"` — значит: одно или больше значений;
- `type=float` — каждое значение будет преобразовано к `float`.

Теперь взаимно исключающие флаги:

```python
fmt_group = calc.add_mutually_exclusive_group()
fmt_group.add_argument(
    "--int",
    dest="as_int",
    action="store_true",
    help="вывести результат как целое число (округление)",
)
fmt_group.add_argument(
    "--precise",
    dest="precise",
    action="store_true",
    help="вывести результат с высокой точностью",
)
```

- `add_mutually_exclusive_group()` — создаёт группу,
  в которой **нельзя одновременно выбрать оба флага**;
- Первый флаг `--int` говорит: “покажи результат как целое число”;
- Второй `--precise` — “выведи десятичное с высокой точностью”.

Если пользователь вдруг напишет `--int --precise` вместе,
`argparse` сам выдаст ошибку и подскажет, что флаги взаимоисключающие.

---

### 6. Подкоманда `file stats` — пример работы с файлами

Сначала дочерний “подparser” для группы `file`:

```python
file_cmd = subparsers.add_parser(
    "file",
    help="операции с файлами (пример работы с Path и ошибками)",
    description="Простейшая статистика по текстовому файлу.",
)
file_sub = file_cmd.add_subparsers(
    title="действия с файлом",
    dest="file_command",
    required=True,
    metavar="FILE_CMD",
)
```

Здесь мы получаем **вложенные подкоманды**:
нужно написать `file stats`, чтобы попасть в нужный режим.

```python
stats_cmd = file_sub.add_parser(
    "stats",
    help="подсчитать строки, слова и символы в файле",
)
stats_cmd.add_argument(
    "path",
    type=Path,
    help="путь к текстовому файлу",
)
```

- аргумент `path` имеет `type=Path` — это класс из `pathlib`,
  который упрощает работу с путями;
- в обработчике `handle_file_stats()` мы проверяем:
  существует ли файл, не является ли он директорией, читаем текст и считаем
  строки/слова/символы.

---

### 7. Функция `write_output()` — единый “центр вывода” с рамкой

```python
frame = "=" * 50
text = "\n".join([frame, *lines, frame])
```

- `frame` — строка из 50 символов `=` — верхняя и нижняя граница блока;
- `lines` — список строк, который подготовил конкретный обработчик;
- мы собираем всё в одну строку с переводами строк и печатаем.

Плюс поддерживаем режим:

- если указан `--output PATH`, то записываем результат в файл;
- иначе печатаем в консоль.

Это важная инженерная идея: **всё форматирование сосредоточено в одном месте**,
поэтому менять внешний вид простым образом.

---

### 8. Функция `main()` — как программа реагирует на запуск

1. Создаём парсер: `parser = build_parser()`.
2. Разбираем аргументы: `args = parser.parse_args(argv)`.
3. Собираем конфигурацию: `config = get_config(args)`.
4. Проверяем, есть ли у `args` атрибут `func` (это наш обработчик подкоманды).
5. Если есть — вызываем его:

```python
args.func(args, config)
```

Всё это обёрнуто в `try/except`:

- `SystemExit` — используется для “нормального” завершения с сообщением об ошибке;
- общий `Exception` — на случай совсем неожиданных ошибок, чтобы программа
  не падала “грязно”, а выдавала хоть какое-то понятное сообщение.

---

### 9. Итог: чему конкретно учит эта программа

1. **Как описать интерфейс командной строки**: какие команды, какие флаги, какие аргументы.
2. **Как разбить логику по функциям**: парсер отдельно, обработчики отдельно, вывод отдельно.
3. **Как работать с разными типами аргументов**: одиночные, списки, флаги, выбор из `choices`.
4. **Как обрабатывать ошибки и аккуратно завершать программу**.
5. **Как делать вывод читаемым**: рамки, заголовки, единый стиль.

По сути, `argparse_demo.py` — это не просто пример синтаксиса `argparse`,
а **мини-шаблон для реальных CLI-проектов**, который можно взять за основу
и постепенно наращивать функциональность.



